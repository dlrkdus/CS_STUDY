# 데이터를 조회하는 2가지 방법

테이블에서 레코드를 찾는 방법

<img width="680" height="349" alt="image" src="https://github.com/user-attachments/assets/192571e9-7ae6-412b-a74b-f5250dde58df" />

## 테이블 풀스캔

- 테이블의 모든 행을 읽어서 조건에 맞는 레코드를 찾는다. (순차 액세스: 연속된 블록을 한 번에 읽음)
- 대량의 데이터에서는 속도가 저하될 수 있지만, 다음과 같은 경우에는 테이블 풀스캔이 유리하다.
    - 전체 데이터 규모가 작을 때
    - 조회 조건이 대부분의 데이터를 포함할 때 
    (예: `WHERE age > 10` 같은 조건이 전체 데이터의 80% 이상을 포함)

## 인덱스 스캔

- 인덱스로 테이블의 특정 위치로 바로 이동해 읽거나 쓰는 방식. (랜덤 액세스: 개별 행의 위치를 찾아가며 읽음)
- **장점**
    - 대부분 **B-Tree** 방식을 사용한다. 따라서 정렬된 구조이기 때문에 `ORDER BY`를 사용할 때 **추가적인 정렬이 필요없다.**
    - 범위 검색에서 빠른 조회가 가능하다.
    - 인덱스가 설정된 컬럼을 기준으로 조인하면 불필요한 데이터 조회를 줄일 수 있다.
- **단점**
    - 쓰기 연산 시 인덱스도 함께 수정되어야 해서 오버헤드가 발생한다. 따라서 **쓰기보단 읽기가 많이 되는 컬럼**을 선택하는 것이 중요하다.
    - 인덱스 저장을 위한 **추가 메모리**가 소비된다.
    - **조회 데이터가 대량일 경우**(테이블의 8-90%), 랜덤 액세스로 인해 행별로 I/O가 발생해서 순차 액세스보다 **성능이 저하**될 수도 있다.
- 따라서 인덱스는 **적은 데이터, 정렬이 필요할 때, 조인에서 특정 컬럼을 기준으로 검색**할 때 사용하면 유리하다.

## 인덱스 최적화

[참고 자료](https://escapefromcoding.tistory.com/777)

인덱스 스캔의 핵심은 **랜덤 액세스 최소화**이다. 

대량 데이터 조회에서 인덱스 스캔이 불리한 이유도 랜덤 액세스 스캔이 너무 많이 일어나기 때문이다. 

**학교에서 이름이 '홍길동'이고 출생월이 '5월~6월'인 학생의 교실을 찾는다고 해보자.**

이름이나 출생월만으로 구성된 단일 인덱스는 랜덤 액세스가 많아지므로 우리는 디스크 I/O를 줄이기 위해 복합인덱스를 쓸 거다. → 이것이 **랜덤 액세스 최소화** 이다.

이 때 테이블 구성에 따른 인덱스 순서도 중요하다 (**인덱스는 순서대로 스캔**하기 때문에)

만약 5-6월생이 많고 홍길동이 적다면 (이름, 출생월) 인덱싱이 유리할 것이다. 이름에서 많이 걸러지기 때문이다.

마찬가지로 홍길동이 많고 5-6월생이 적다면 (출생월, 이름)이 유리할 것이다.

→ 이것이 **인덱스 스캔 효율화** 이다.

**SQL이 느린 이유는 대부분 디스크 I/O이기 때문에, 랜덤 액세스 최소화가 중요하다.** 이 조건이 만족된 후에 인덱스 스캔 효율화를 고민한다.

# 언제 인덱스를 타지 않는가? 

인덱스를 타지 않는 경우는 2가지다.

## 풀 테이블 스캔이 인덱스 스캔보다 효율적인 경우 (인덱스 배제)

이를 이해하기 위해선 랜덤 I/O와 순차 I/O에 대한 이해가 필요하다.

인덱스 스캔은 랜덤 I/O고 풀 테이블 스캔은 순차 I/O다.

디스크를 읽을 땐 디스크의 바늘이 돌아가며 해당 데이터가 위치하는 곳으로 이동해 데이터를 읽는데, 순차 I/O는 이 바늘이 한 방향으로 이동하지만 랜덤 I/O는 랜덤으로 움직인다. 따라서 읽어야 하는 데이터가 많아질 수록 **랜덤 I/O는 바늘 회전(접근) 시간이 길어질 수 밖에 없다.**

만약 데이터가 테이블에서 대부분을 차지하는 비중이라면, 풀 테이블 스캔의 순차 I/O가 더 빠를 수 있다. 옵티마이저는 실행 계획을 세울 때 테이블 정보를 읽어와 이를 바탕으로 더 성능이 좋은 스캔 방식을 택한다.

값 종류가 너무 적을 때 (선택도가 낮을 때) 도 풀 테이블 스캔이 낫다.

## 잘못된 사용으로 인덱스를 못 타는 경우

1. 복합 인덱스의 선행 컬럼이 null인 경우
    
    수직 탐색을 탈 기준이 사라져 풀 테이블 스캔
    
2. 컬럼에 함수나 연산을 쓰는 경우
3. 와일드카드를 검색어 앞에 쓰는 경우
    
    마찬가지로 수직탐색을 할 기준이 사라져서 인덱스 못 탐, 인덱스 풀 스캔 또는 풀 테이블 스캔
    
4. OR절을 쓰면 Index Merge 전략을 쓰지만 옵티마이저가 안 쓸 수도 있음
    
    UNION ALL을 사용하는게 좋음
    
5. 정렬 방향이 다를 때

# 인덱스 종류 

**커버링 인덱스** : 필요한 데이터를 인덱스에서 모두 가져올 수 있어 테이블 자체에 접근을 하지 않을 수 있는 인덱스

**클러스터 인덱스** : 리프 노드에 실제 레코드의 데이터를 저장하는 인덱스, MySQL에서는 pk가 곧 클러스터 인덱스다. 테이블 당 하나의 필드만 클러스터 인덱스가 될 수 있다.

만약 PK가 없다면 NOT NULL + UNIQUE 제약 컬럼이 클러스터 인덱스가 된다.

만약 Post 테이블의 id라면, 실제로는 리프노드에 다음과 같이 저장돼있다.

```java
(1, 'Post Title 1', 'This is the content of post 1.')
(2, 'Post Title 2', 'This is the content of post 2.')
(3, 'Post Title 3', 'This is the content of post 3.')
```

따라서 다음과 같은 쿼리를 날릴 시, 클러스터 인덱스는 커버링 인덱스로서 동작한다. 따라서 인덱스에 접근하는 I/O만 1번 발생한다.

```java
SELECT title FROM post WHERE id = 1;
```

**논클러스터 인덱스** : 리프 노드에 실제 데이터와 레코드 주소를 저장하는 인덱스, 일반적인 인덱스가 논 클러스터 인덱스다. 

**Full Text 인덱스** : 역색인 구조로 되어 있는 인덱스, 일반적인 LIKE 쿼리는 와일드 카드가 앞에 붙었을 때 인덱스를 못 탄다. 인덱스는 앞글자로 수직 탐색을 해야 하는데 앞글자 자체가 안 정해져있기 때문에 수직 탐색 자체를 못 타기 때문이다. 따라서 키워드 검색은 Full Text 인덱스를 써야 인덱스를 탈 수 있다.

**복합 인덱스** : 자주 같이 묶이는 조합은 단일 인덱스를 독립적으로 타는 것보다 복합 인덱스로 타는게 유리하다. 복합 인덱스는 수직 탐색을 1번만 하기 때문이다. 

순서도 중요한데, 선수 컬럼이 null이 되면 인덱스 자체가 무용지물이 되니 주의하고, 되도록 많이 거를 수 있는 필드 순으로 배치해야 수평 탐색 범위를 줄일 수 있다.

자주 조회되는 필드 조합은 복합 인덱스로 만들어 커버링 인덱스로 사용할 수도 있다.

**인덱스의 자료구조** : B+Tree (B-Tree에서 리프노드가 연결리스트 버전, 수평탐색 유리), 해시 인덱스 

## 기능 기반

| **인덱스 종류** | **설명** | **주요 특징** |
| --- | --- | --- |
| **Primary Index (클러스터형)** | 기본 키에 자동 생성되는 인덱스 | 실제 데이터도 정렬되어 있음 (클러스터형) |
| **Secondary Index (보조 인덱스)** | 비클러스터형, 일반적인 인덱스 | 데이터는 따로 있음 (포인터만 저장) |
| **Unique Index** | 중복 방지 | 제약조건(UNIQUE)과 동일 기능 |
| **Composite Index(복합 인덱스)** | 여러 컬럼으로 구성된 인덱스 | 왼쪽부터 순서 중요 (선행 컬럼 원칙) |
| **Partial Index** | 조건을 만족하는 행만 인덱싱 | 예: WHERE deleted_at IS NULL |
| **Function-based Index** | 함수 적용 결과를 인덱싱 | 예: LOWER(name) 같은 가공된 값에 사용 |
| **Covering Index** | 인덱스만으로 SELECT가 가능한 인덱스 | 쿼리 성능 최적화 (인덱스 스캔만으로 처리) |

## 물리 기반

| **클러스터형 인덱스 (Clustered)** | 인덱스 자체가 실제 데이터를 포함함 (InnoDB의 PK) |
| --- | --- |
| **비클러스터형 인덱스 (Non-Clustered)** | 인덱스는 포인터만 가지고 있고, 실제 데이터는 따로 존재함 |
| **Reverse Key Index** | 키를 거꾸로 저장 |
- 커버링 인덱스 예시
    
    ```sql
    CREATE INDEX idx_age_name ON users(age, name);
    ```
    
    ```sql
    SELECT name FROM users WHERE age = 25;
    ```
