## 왜 인덱스는 B-Tree를 쓸까?

<img width="1125" height="349" alt="image" src="https://github.com/user-attachments/assets/7991e718-dee1-4065-964b-793dbd897fa3" />

인덱스를 쓰는 이유 : 값을 빠르게 찾기 위해.

M진 트리를 쓰면 트리 높이가 낮아지기 때문에 값을 O(logmN)만에 찾아낼 수 있다.

균형을 맞춰야되니 자가 균형 M진 트리를 쓴다.

인덱스는 정렬 연산과 범위 검색도 최적화하고 싶기 때문에 자가 균형 + 정렬 + M진 트리인 B-Tree를 채택했다.

<aside>

1. **항상 정렬된 상태로 특정 값보다 크고 작은 부등호 연산에 문제가 없다.**
2. **참조 포인터가 적어 방대한 데이터 양에도 빠른 메모리 접근이 가능하다. (M진 트리라서)**
3. **데이터 탐색뿐 아니라, 저장, 수정, 삭제에도 항상 O(logN)의 시간 복잡도를 가진다.**
</aside>

## B+Tree

근데 사실 RDBMS는 B+Tree 기반이다.

이 B-Tree에서 11 이상 20 이하 값들을 조회해온다 해보자.

11,12 를 조회해오고, 14를 조회해오고, 15를 조회해오고,, 레벨을 오르내려야 된다. 그럼 그만큼 디스크 I/O가 더 많이 발생한다.

<img width="960" height="344" alt="image" src="https://github.com/user-attachments/assets/8a87ab6b-5974-4cd1-b9e6-97430671116b" />

따라서 B+Tree는 모든 값들을 리프노드로 내려버려서 리프 노드에서만 탐색하도록 했다. 레벨을 오르내릴 필요가 없으니 수직 탐색은 단 한 번만 발생한다.

이때 리프 노드들은 디스크에서 랜덤 I/O로 읽어와야 하는데, 연결 리스트로 연결함으로써 선형시간만에 가져올 수 있다.
